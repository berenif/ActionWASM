export class GameLoader {
  private wasmModule: any = null;
  public onReady: (() => void) | null = null;

  async init() {
    try {
      // Try to load the WASM module
      await this.loadWasmModule();
      
      if (this.onReady) {
        this.onReady();
      }
    } catch (error) {
      console.error('Failed to load WASM module:', error);
      // Fallback to pure JavaScript implementation if needed
      this.initFallback();
    }
  }

  private async loadWasmModule() {
    // Check if the WASM module exists
    try {
      // Dynamically import the WASM module
      // This will be generated by wasm-pack
      const wasmModule = await import('./wasm/wasm_multiplayer_game.js').catch(() => null);
      
      if (wasmModule) {
        // Initialize the WASM module
        await wasmModule.default();
        this.wasmModule = wasmModule;
        
        // Start the game
        if (wasmModule.run) {
          wasmModule.run();
        }
        
        console.log('WASM module loaded successfully');
      } else {
        throw new Error('WASM module not found');
      }
    } catch (error) {
      console.warn('WASM module not available, using fallback');
      throw error;
    }
  }

  private initFallback() {
    console.log('Initializing JavaScript fallback mode');
    
    // Create a simple canvas-based game as fallback
    const canvas = document.getElementById('game-canvas') as HTMLCanvasElement;
    if (!canvas) return;

    // Set canvas size
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Simple game state
    const gameState = {
      players: new Map<string, Player>(),
      localPlayer: null as Player | null,
    };

    interface Player {
      id: string;
      x: number;
      y: number;
      vx: number;
      vy: number;
      color: string;
    }

    // Create local player
    const localPlayer: Player = {
      id: 'local',
      x: canvas.width / 2,
      y: canvas.height / 2,
      vx: 0,
      vy: 0,
      color: '#4CAF50'
    };
    gameState.localPlayer = localPlayer;
    gameState.players.set(localPlayer.id, localPlayer);

    // Input handling
    const keys: { [key: string]: boolean } = {};
    
    window.addEventListener('keydown', (e) => {
      keys[e.key.toLowerCase()] = true;
    });

    window.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    // Game loop
    let lastTime = 0;
    const gameLoop = (timestamp: number) => {
      const deltaTime = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      // Update player based on input
      if (gameState.localPlayer) {
        const speed = 300; // pixels per second
        gameState.localPlayer.vx = 0;
        gameState.localPlayer.vy = 0;

        if (keys['w'] || keys['arrowup']) gameState.localPlayer.vy = -speed;
        if (keys['s'] || keys['arrowdown']) gameState.localPlayer.vy = speed;
        if (keys['a'] || keys['arrowleft']) gameState.localPlayer.vx = -speed;
        if (keys['d'] || keys['arrowright']) gameState.localPlayer.vx = speed;

        // Update position
        gameState.localPlayer.x += gameState.localPlayer.vx * deltaTime;
        gameState.localPlayer.y += gameState.localPlayer.vy * deltaTime;

        // Keep player in bounds
        gameState.localPlayer.x = Math.max(20, Math.min(canvas.width - 20, gameState.localPlayer.x));
        gameState.localPlayer.y = Math.max(20, Math.min(canvas.height - 20, gameState.localPlayer.y));
      }

      // Clear canvas
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw grid
      ctx.strokeStyle = '#16213e';
      ctx.lineWidth = 1;
      const gridSize = 50;
      
      for (let x = 0; x < canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      
      for (let y = 0; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Draw players
      gameState.players.forEach(player => {
        ctx.fillStyle = player.color;
        ctx.beginPath();
        ctx.arc(player.x, player.y, 15, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw player ID
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(player.id, player.x, player.y - 20);
      });

      // Draw instructions if no WASM
      ctx.fillStyle = '#ffffff';
      ctx.font = '16px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('JavaScript Fallback Mode (WASM not available)', canvas.width / 2, 30);

      requestAnimationFrame(gameLoop);
    };

    // Handle window resize
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });

    // Start the game loop
    requestAnimationFrame(gameLoop);

    // Mark as ready
    if (this.onReady) {
      this.onReady();
    }
  }

  // Public API for game interaction
  public sendGameMessage(message: any) {
    if (this.wasmModule && this.wasmModule.send_message) {
      this.wasmModule.send_message(JSON.stringify(message));
    }
  }

  public updateGameState(state: any) {
    if (this.wasmModule && this.wasmModule.update_state) {
      this.wasmModule.update_state(JSON.stringify(state));
    }
  }
}